* Migration Guide from ido to helm
:PROPERTIES:
:SUMMARY: Get an ido like interface with the power of helm.
:END:

** Ido2Helm

This guide is for people which used ido in the past and want
helm to behave more like ido. For now the configuration snippets inlcude the following
features:

- Always pop up at the bottom
- Input in header line
- No mode-line above the helm buffer.
- Flx support
- DEL and RETURN for file navigation like in ido


:IMPORTANT:
This is work in progress. If you encounter any problems let me know.
Some of this is my own work, but most is based on work of others.
I included references to the origins.

** Screenshot

[[./screenshot.png]]

** Appearance

Only pop up at the bottom.

#+BEGIN_SRC emacs-lisp
(setq helm-split-window-in-side-p t)

(add-to-list 'display-buffer-alist
             '("\\`\\*helm.*\\*\\'"
               (display-buffer-in-side-window)
               (inhibit-same-window . t)
               (window-height . 0.4)))

(setq helm-swoop-split-with-multiple-windows nil
        helm-swoop-split-direction 'split-window-vertically
        helm-swoop-split-window-function 'helm-default-display-buffer)

#+END_SRC

Input in header line and hide the mode-lines above.

Reference:
[[http://emacs.stackexchange.com/a/15250/9198][StackExchange]]

#+BEGIN_SRC emacs-lisp
(setq helm-echo-input-in-header-line t)

(defvar bottom-buffers nil
  "List of bottom buffers before helm session.
    Its element is a pair of `buffer-name' and `mode-line-format'.")

(defun bottom-buffers-init ()
  (setq-local mode-line-format (default-value 'mode-line-format))
  (setq bottom-buffers
        (cl-loop for w in (window-list)
                 when (window-at-side-p w 'bottom)
                 collect (with-current-buffer (window-buffer w)
                           (cons (buffer-name) mode-line-format)))))


(defun bottom-buffers-hide-mode-line ()
  (setq-default cursor-in-non-selected-windows nil)
  (mapc (lambda (elt)
          (with-current-buffer (car elt)
            (setq-local mode-line-format nil)))
        bottom-buffers))


(defun bottom-buffers-show-mode-line ()
  (setq-default cursor-in-non-selected-windows t)
  (when bottom-buffers
    (mapc (lambda (elt)
            (with-current-buffer (car elt)
              (setq-local mode-line-format (cdr elt))))
          bottom-buffers)
    (setq bottom-buffers nil)))

(defun helm-keyboard-quit-advice (orig-func &rest args)
  (bottom-buffers-show-mode-line)
  (apply orig-func args))


(add-hook 'helm-before-initialize-hook #'bottom-buffers-init)
(add-hook 'helm-after-initialize-hook #'bottom-buffers-hide-mode-line)
(add-hook 'helm-exit-minibuffer-hook #'bottom-buffers-show-mode-line)
(add-hook 'helm-cleanup-hook #'bottom-buffers-show-mode-line)
(advice-add 'helm-keyboard-quit :around #'helm-keyboard-quit-advice)
#+END_SRC

** File Navigation

Backspace goes to the upper folder if you are not inside a filename,
and Return will select a file or navigate into the directory if
it is one.

Reference:
[[http://emacs.stackexchange.com/a/7896/9198][StackExchange]]

#+BEGIN_SRC emacs-lisp
(defun dwim-helm-find-files-up-one-level-maybe ()
  (interactive)
  (if (looking-back "/" 1)
      (call-interactively 'helm-find-files-up-one-level)
    (delete-backward-char 1)))

(define-key helm-read-file-map (kbd "<backsqpace>") 'dwim-helm-find-files-up-one-level-maybe)
(define-key helm-read-file-map (kbd "DEL") 'dwim-helm-find-files-up-one-level-maybe)
(define-key helm-find-files-map (kbd "<backspace>") 'dwim-helm-find-files-up-one-level-maybe)
(define-key helm-find-files-map (kbd "DEL") 'dwim-helm-find-files-up-one-level-maybe)

(defun dwim-helm-find-files-navigate-forward (orig-fun &rest args)
  "Adjust how helm-execute-persistent actions behaves, depending on context"
  (if (file-directory-p (helm-get-selection))
      (apply orig-fun args)
    (helm-maybe-exit-minibuffer)))


(define-key helm-map (kbd "<return>") 'helm-maybe-exit-minibuffer)
(define-key helm-map (kbd "RET") 'helm-maybe-exit-minibuffer)
(define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
(define-key helm-read-file-map (kbd "<return>") 'helm-execute-persistent-action)
(define-key helm-find-files-map (kbd "RET") 'helm-execute-persistent-action)
(define-key helm-read-file-map (kbd "RET") 'helm-execute-persistent-action)

(advice-add 'helm-execute-persistent-action :around #'dwim-helm-find-files-navigate-forward)
#+END_SRC
** Flx

Flx support for helm.

Reference:
[[https://github.com/PythonNut/emacs-config/blob/f1df3ac16410bfa72d88855325bd6c2de56f587b/modules/config-helm.el#L33#L89][GithubRepo]]

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm
  (require 'flx)
  (defvar helm-flx-cache (flx-make-string-cache #'flx-get-heatmap-file))
  (defadvice helm-score-candidate-for-pattern
      (around flx-score (candidate pattern) activate preactivate compile)
    (setq ad-return-value
          (or
           (car (flx-score
                 (substring-no-properties candidate)
                 (substring-no-properties pattern)
                 helm-flx-cache))
           0)))

  (defadvice helm-fuzzy-default-highlight-match
      (around flx-highlight (candidate) activate preactivate compile)
    "The default function to highlight matches in fuzzy matching.
It is meant to use with `filter-one-by-one' slot."
    (setq ad-return-value
          (let* ((pair (and (consp candidate) candidate))
                 (display (if pair (car pair) candidate))
                 (real (cdr pair)))
            (with-temp-buffer
              (insert display)
              (goto-char (point-min))
              (if (string-match-p " " helm-pattern)
                  (cl-loop with pattern = (split-string helm-pattern)
                           for p in pattern
                           do (when (search-forward (substring-no-properties p) nil t)
                                (add-text-properties
                                 (match-beginning 0) (match-end 0) '(face helm-match))))
                (cl-loop with pattern = (cdr (flx-score
                                              (substring-no-properties display)
                                              helm-pattern helm-flx-cache))
                         for index in pattern
                         do (add-text-properties
                             (1+ index) (+ 2 index) '(face helm-match))))
              (setq display (buffer-string)))
            (if real (cons display real) display))))

  (setq
   helm-buffers-fuzzy-matching t
   helm-imenu-fuzzy-match t
   helm-recentf-fuzzy-match t
   helm-locate-fuzzy-match nil
   helm-M-x-fuzzy-match t
   helm-semantic-fuzzy-match t))
#+END_SRC
